var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"API for Odrpack.","category":"page"},{"location":"api/#Odrpack.OdrResult","page":"API","title":"Odrpack.OdrResult","text":"OdrResult\n\nResults of an Orthogonal Distance Regression (ODR) computation.\n\nFields\n\nbeta::Vector{Float64}: Estimated parameters of the model.\ndelta::Union{Vector{Float64},Matrix{Float64}}: Differences between the observed and fitted x values.\neps::Union{Vector{Float64},Matrix{Float64}}: Differences between the observed and fitted y values.\nxplusd::Union{Vector{Float64},Matrix{Float64}}: Adjusted x values after fitting, x + delta.\nyest::Union{Vector{Float64},Matrix{Float64}}: Estimated y values corresponding to the fitted model, y + eps.\nsd_beta::Vector{Float64}: Standard deviations of the estimated parameters.\ncov_beta::Matrix{Float64}: Covariance matrix of the estimated parameters.\nres_var::Float64: Residual variance, indicating the variance of the residuals.\nnfev::Int: Number of function evaluations during the fitting process.\nnjev::Int: Number of Jacobian evaluations during the fitting process.\nniter::Int: Number of iterations performed in the optimization process.\nirank::Int: Rank of the Jacobian matrix at the solution.\ninv_condnum::Float64: Inverse of the condition number of the Jacobian matrix.\ninfo::Int: Status code of the fitting process (e.g., success or failure).\nstopreason::String: Message indicating the reason for stopping.\nsuccess::Bool: Whether the fitting process was successful.\nsum_square::Float64: Sum of squared residuals (including both delta and eps).\nsum_square_delta::Float64: Sum of squared differences between observed and fitted x values.\nsum_square_eps::Float64: Sum of squared differences between observed and fitted y values.\n_iwork::Vector{Int32}: Integer workspace array used internally by odrpack. Typically for advanced debugging.\n_rwork::Vector{Float64}: Floating-point workspace array used internally by odrpack. Typically for advanced debugging.\n\n\n\n\n\n","category":"type"},{"location":"api/#Odrpack.OdrStop","page":"API","title":"Odrpack.OdrStop","text":"OdrStop <: Exception\n\nException to stop the regression.\n\nThis exception can be raised in the model function or its Jacobians to stop the regression process.\n\n\n\n\n\n","category":"type"},{"location":"api/#Odrpack.Thunk","page":"API","title":"Odrpack.Thunk","text":"Thunk\n\nA mutable container used to pass around the model function, jacobians, and related information without creating a closure. cFunction does not support closures in certain platforms (e.g.,  macOS ARM).\n\nFields\n\nf!::Function   The main function to be evaluated.\njac_beta!::Union{Function,Nothing}   Optional Jacobian with respect to parameter(s) β. \njac_x!::Union{Function,Nothing}   Optional Jacobian with respect to input(s) x. \nx_is_2d::Bool   Whether the input x is treated as a matrix (true) or a vector (false).\ny_is_2d::Bool   Whether the output y = f(x, β) is treated as a matrix (true) or a vector (false).\n\n\n\n\n\n","category":"type"},{"location":"api/#Odrpack.odr_callback!-Tuple{Ptr{Int32}, Ptr{Int32}, Ptr{Int32}, Ptr{Int32}, Ptr{Int32}, Ptr{Float64}, Ptr{Float64}, Ptr{Int32}, Ptr{Int32}, Ptr{Int32}, Ptr{Float64}, Ptr{Float64}, Ptr{Float64}, Ptr{Int32}, Ptr{Nothing}}","page":"API","title":"Odrpack.odr_callback!","text":"Callback function invoked from odrpack to evaluate the model function and, optionally, its Jacobians. The actual julia functions are stored in the Thunk struct, which is passed as a void pointer. This is used to call the appropriate functions without creating closures.\n\n\n\n\n\n","category":"method"},{"location":"api/#Odrpack.odr_fit-Tuple{Function, VecOrMat{Float64}, VecOrMat{Float64}, Vector{Float64}}","page":"API","title":"Odrpack.odr_fit","text":"odr_fit(f!, xdata, ydata, beta0; kwargs...) -> OdrResult\n\nSolve a weighted orthogonal distance regression (ODR) problem, also known as errors-in-variables regression.\n\nArguments\n\nf!::Function: Function to be fitted, with the signature f!(x, beta, y). It must modify y in-place to have the same shape as ydata.\nxdata::VecOrMat{Float64}: Array of shape (n,) or (n, m) containing the observed values of the explanatory variable(s).\nydata::VecOrMat{Float64}: Array of shape (n,) or (n, q) containing the observed values of the response variable(s). When the model is explicit, ydata must  contain a value for each observation. To ignore specific values (e.g., missing data), set the corresponding entry in weight_y to zero. When the model is implicit, ydata is not used  (but must be defined).\nbeta0::Vector{Float64}: Array of shape (np,) with the initial guesses of the model parameters, within the optional bounds specified by bounds.\n\nKeywords\n\nweight_x::Union{Float64,Vector{Float64},Matrix{Float64},Array{Float64,3},Nothing}=nothing: Scalar or array specifying how the errors on xdata are to be weighted. If weight_x is a  scalar, then it is used for all data points. If weight_x is an array of shape (n,) and  m==1, then weight_x[i] represents the weight for xdata[i]. If weight_x is an array of shape (m,), then it represents the diagonal of the covariant weighting matrix for all data points. If weight_x is an array of shape (m, m), then it represents the full covariant  weighting matrix for all data points. If weight_x is an array of shape (n, m), then  weight_x[i, :] represents the diagonal of the covariant weighting matrix for xdata[i, :]. If weight_x is an array of shape (n, m, m), then weight_x[i, :, :] represents the full covariant weighting matrix for xdata[i, :]. For a comprehensive description of the options, refer to page 26 of the ODRPACK95 guide. By default, weight_x is set to one for all xdata points.\nweight_y::Union{Float64,Vector{Float64},Matrix{Float64},Array{Float64,3},Nothing}=nothing: Scalar or array specifying how the errors on ydata are to be weighted. If weight_y is a  scalar, then it is used for all data points. If weight_y is an array of shape (n,) and  q==1, then weight_y[i] represents the weight for ydata[i]. If weight_y is an array of shape (q), then it represents the diagonal of the covariant weighting matrix for all data points. If weight_y is an array of shape (q, q), then it represents the full covariant  weighting matrix for all data points. If weight_y is an array of shape (n, q), then  weight_y[i, :] represents the diagonal of the covariant weighting matrix for ydata[i, :]. If weight_y is an array of shape (n, q, q), then weight_y[i, :, :] represents the full covariant weighting matrix for ydata[i, :]. For a comprehensive description of the options, refer to page 25 of the ODRPACK95 guide. By default, weight_y is set to one for all ydata points.\nbounds::Tuple{Union{Vector{Float64},Nothing},Union{Vector{Float64},Nothing}}=(nothing, nothing): Tuple of arrays with the same shape as beta0, specifying the lower and upper bounds of the  model parameters. The first array contains the lower bounds, and the second contains the upper bounds. By default, the bounds are set to negative and positive infinity, respectively, for  all elements of beta.\ntask::Symbol=:explicitODR: Specifies the regression task to be performed. :explicitODR solves an orthogonal distance regression problem with an explicit model. :implicitODR handles models defined implicitly. :OLS performs ordinary least squares fitting.\nfix_beta::Union{Vector{Bool},Nothing}=nothing: Array with the same shape as beta0, specifying which elements of beta are to be held fixed. true means the parameter is fixed; false means it is adjustable. By default, all elements of beta are set to false. \nfix_x::Union{VecOrMat{Bool},Nothing}=nothing: Array with the same shape as xdata, specifying which elements of xdata are to be held fixed. Alternatively, it can be a rank-1 array of shape (m,) or (n,), in which case it will be  broadcast along the other axis. true means the element is fixed; false means it is adjustable. By default, in orthogonal distance regression mode, all elements of fix_x are set to false. In ordinary least squares mode (task=:OLS), all xdata values are automatically treated  as fixed.\njac_beta!::Union{Function,Nothing}=nothing: Jacobian of the function to be fitted with respect to beta, with the signature jac_beta!(x, beta, jb). It must modify the result jb in-place, with shape (n, np, q). By default, the Jacobian is approximated numerically using the finite difference scheme specified by diff_scheme.\njac_x!::Union{Function,Nothing}=nothing: Jacobian of the function to be fitted with respect to x, with the signature jac_x!(x, beta, jx). It must modify the result jx in-place, with shape (n, m, q). By default, the Jacobian is  approximated numerically using the finite difference scheme specified by diff_scheme.\ndelta0::Union{VecOrMat{Float64},Nothing}=nothing: Array with the same shape as xdata, containing the initial guesses of the errors in the  explanatory variable. By default, delta0 is set to zero for all elements of xdata.\ndiff_scheme::Symbol=:forward: Finite difference scheme used to approximate the Jacobian matrices when the user does not  provide jac_beta! and jac_x!. The default method is forward (:forward) differences. Central (:central) differences are generally more accurate but require one additional f! evaluation per partial derivative.\nreport::Symbol=:none: Specifies the level of computation reporting. :none disables all output. :short prints  a brief initial and final summary. :long provides a detailed initial and final summary.  :iteration outputs information at each iteration step in addition to the detailed summaries. This is useful for debugging or monitoring progress.\nmaxit::Integer=50: Maximum number of allowed iterations.\nndigit::Union{Integer,Nothing}=nothing: Number of reliable decimal digits in the values  computed by the model function f! and its Jacobians jac_beta!, and jac_x!. By default, the value is numerically determined by evaluating f!. \ntaufac::Union{Float64,Nothing}=nothing: Factor ranging from 0 to 1 to initialize the trust region radius. The default value is 1.  Reducing taufac may be appropriate if, at the first iteration, the computed results for the full Gauss-Newton step cause an overflow, or cause beta and/or delta to leave the region of interest. \nsstol::Union{Float64,Nothing}=nothing: Factor ranging from 0 to 1 specifying the stopping tolerance for the sum of the squares  convergence. The default value is eps()^(1/2), where eps() is the machine precision in  Float64.\npartol::Union{Float64,Nothing}=nothing: Factor ranging from 0 to 1 specifying the stopping tolerance for parameter convergence  (i.e., beta and delta). When the model is explicit, the default value is eps()^(2/3),  and when the model is implicit, the default value is eps()^(1/3), where eps() is the machine precision in Float64.\nstep_beta::Union{Vector{Float64},Nothing}=nothing: Array with the same shape as beta0 containing the relative step sizes used to compute the finite difference derivatives with respect to the model parameters. By default, the step size is set internally based on the value of ndigit and the type of finite differences specified by diff_scheme. For additional details, refer to pages 31 and 78 of the ODRPACK95 guide.\nstep_delta::Union{VecOrMat{Float64},Nothing}=nothing: Array with the same shape as xdata, containing the relative step sizes used to compute the finite difference derivatives with respect to the errors in the explanatory variable.  Alternatively, it can be a rank-1 array of shape (m,) or (n,), in which case it will be  broadcast along the other axis. By default, step size is set internally based on the value of ndigit and the type of finite differences specified by diff_scheme. For additional  details, refer to pages 31 and 78 of the ODRPACK95 guide.\nscale_beta::Union{Vector{Float64},Nothing}=nothing: Array with the same shape as beta0 containing the scale values of the model parameters.  Scaling is used to improve the numerical stability of the regression, but does not affect the problem specification. Scaling should not be confused with the weighting matrices weight_x  and weight_y. By default, the scale is set internally based on the relative magnitudes of  beta. For further details, refer to pages 32 and 84 of the ODRPACK95 guide.\nscale_delta::Union{VecOrMat{Float64},Nothing}=nothing: Array with the same shape as xdata, containing the scale values of the errors in the  explanatory variable. Alternatively, it can be a rank-1 array of shape (m,) or (n,), in  which case it will be broadcast along the other axis. Scaling is used to improve the numerical stability of the regression, but does not affect the problem specification. Scaling should  not be confused with the weighting matrices weight_x and weight_y. By default, the scale  is set internally based on the relative magnitudes of xdata. For further details, refer to  pages 32 and 85 of the ODRPACK95 guide.\nrptfile::Union{String,Nothing}=nothing: File name for storing the computation reports, as defined by report. By default, the reports are sent to standard output.\nerrfile::Union{String,Nothing}=nothing: File name for storing the error reports, as defined by report. By default, the reports are  sent to standard output.\n\nReturns\n\nOdrResult: An object containing the results of the regression.\n\nReferences\n\n[1] Jason W. Zwolak, Paul T. Boggs, and Layne T. Watson.     Algorithm 869: ODRPACK95: A weighted orthogonal distance regression code      with bound constraints. ACM Trans. Math. Softw. 33, 4 (August 2007), 27-es.     https://doi.org/10.1145/1268776.1268782\n\n[2] Jason W. Zwolak, Paul T. Boggs, and Layne T. Watson. User's Reference     Guide for ODRPACK95, 2005.     https://github.com/HugoMVale/odrpack95/blob/main/original/Doc/guide.pdf\n\nExamples\n\nusing Odrpack\n\nfunction f!(x::Vector{Float64}, beta::Vector{Float64}, y::Vector{Float64})\n    y .= beta[1] .* exp.(beta[2] .* x)\n    return nothing\nend\n\nxdata = [0.982, 1.998, 4.978, 6.01]\nydata = [2.7, 7.4, 148.0, 403.0]\n\nbeta0 = [2.0, 0.5]\nbounds = ([0.0, 0.0], [10.0, 0.9])\n\nsol = odr_fit(\n    f!,\n    xdata,\n    ydata,\n    beta0,\n    bounds=bounds,\n    # rptfile=\"test_output.txt\",\n    # report=:long\n)\n\nprintln(\"Optimized β    :\", sol.beta)\nprintln(\"Optimized δ    :\", sol.delta)\nprintln(\"Optimized x + δ:\", sol.xplusd)\n \n\n\n\n\n\n","category":"method"},{"location":"api/#Odrpack.Auxiliary","page":"API","title":"Odrpack.Auxiliary","text":"Auxiliary functions for odrpack.\n\nThis module provides a Julia interface to the auxiliary routines from the Fortran odrpack library.\n\n\n\n\n\n","category":"module"},{"location":"api/#Odrpack.Auxiliary.close_file-Tuple{Ref{Int32}}","page":"API","title":"Odrpack.Auxiliary.close_file","text":"close_file(lun) -> Int32\n\nClose a file associated with a specified logical unit number.\n\nArguments\n\nlun::Ref{Int32}: The logical unit number of the file to close.\n\nReturns\n\nInt32: An error code (compiler dependent). A return value of 0 typically indicates successful closure.\n\n\n\n\n\n","category":"method"},{"location":"api/#Odrpack.Auxiliary.loc_iwork-Tuple{Integer, Integer, Integer}","page":"API","title":"Odrpack.Auxiliary.loc_iwork","text":"loc_iwork(m, q, np) -> Iworkidx\n\nGet storage locations within the integer work space.\n\nArguments\n\nm::Integer: Number of columns of data in the explanatory variable.\nq::Integer: Number of responses per observation.\nnp::Integer: Number of function parameters.\n\nReturns\n\nIworkidx: A structure containing the 0-based indexes of the integer work array.\n\n\n\n\n\n","category":"method"},{"location":"api/#Odrpack.Auxiliary.loc_rwork-Tuple{Integer, Integer, Integer, Integer, Integer, Integer, Bool}","page":"API","title":"Odrpack.Auxiliary.loc_rwork","text":"loc_rwork(n, m, q, np, ldwe, ld2we, isodr) -> Rworkidx\n\nGet storage locations within the real work space.\n\nArguments\n\nn::Integer: Number of observations.\nm::Integer: Number of columns of data in the explanatory variable.\nq::Integer: Number of responses per observation.\nnp::Integer: Number of function parameters.\nldwe::Integer: Leading dimension of the we array.\nld2we::Integer: Second dimension of the we array.\nisodr::Bool: Indicates whether the solution is by ODR (true) or by OLS (false).\n\nReturns\n\nRworkidx: A structure containing the 0-based indexes of the real work array.\n\n\n\n\n\n","category":"method"},{"location":"api/#Odrpack.Auxiliary.open_file-Tuple{AbstractString, Ref{Int32}}","page":"API","title":"Odrpack.Auxiliary.open_file","text":"open_file(filename, lun) -> Int32\n\nOpen a new file associated with a specified logical unit number.\n\nArguments\n\nfilename::AbstractString: String containing the file name.\nlun::Ref{Cint}: Logical unit number. This value will be modified by the function.\n\nReturns\n\nInt32: Error code (compiler dependent). A value of 0 typically indicates success.\n\n\n\n\n\n","category":"method"},{"location":"api/#Odrpack.Auxiliary.stop_message-Tuple{Integer}","page":"API","title":"Odrpack.Auxiliary.stop_message","text":"stop_message(info) -> String\n\nReturn a human-readable message based on the stopping condition returned by odrpack in  the info argument of the result.\n\nArguments\n\ninfo::Integer: value of the info argument returned by odrpack. This value is used to determine the stopping condition.\n\nReturns\n\n::String: human-readable string describing the stopping condition.\n\n\n\n\n\n","category":"method"},{"location":"api/#Odrpack.Auxiliary.workspace_dimensions-Tuple{Integer, Integer, Integer, Integer, Bool}","page":"API","title":"Odrpack.Auxiliary.workspace_dimensions","text":"workspace_dimensions(n, m, q, np, isodr) -> Tuple{Int32, Int32}\n\nCalculate the dimensions of the workspace arrays required by the underlying Fortran library.\n\nArguments\n\nn::Integer: Number of observations.\nm::Integer: Number of columns of data in the explanatory variable.\nq::Integer: Number of responses per observation.\nnp::Integer: Number of function parameters.\nisodr::Bool: Variable designating whether the solution is by ODR (true) or by OLS (false).\n\nReturns\n\nTuple{Int32, Int32}: A tuple containing the lengths of the real and integer work arrays  (lrwork, liwork).\n\n\n\n\n\n","category":"method"},{"location":"examples/implicit-model/#Implicit-orthogonal-regression","page":"Implicit orthogonal regression","title":"Implicit orthogonal regression","text":"","category":"section"},{"location":"examples/implicit-model/","page":"Implicit orthogonal regression","title":"Implicit orthogonal regression","text":"Estimate the parameters of an ellipse from a set of coordinates.","category":"page"},{"location":"examples/implicit-model/","page":"Implicit orthogonal regression","title":"Implicit orthogonal regression","text":"beginalign*\nf(bmX bmbeta)  = fracleft(x-x_0)costheta + (y-y_0)sinthetaright^2a^2 \n + fracleft(y-y_0)costheta -(x-x_0)sinthetaright^2b^2 - 1 = 0\nendalign*","category":"page"},{"location":"examples/implicit-model/","page":"Implicit orthogonal regression","title":"Implicit orthogonal regression","text":"bmX = (xy)","category":"page"},{"location":"examples/implicit-model/","page":"Implicit orthogonal regression","title":"Implicit orthogonal regression","text":"bmbeta = (x_0 y_0 a b theta)","category":"page"},{"location":"examples/implicit-model/","page":"Implicit orthogonal regression","title":"Implicit orthogonal regression","text":"using Odrpack\nusing Plots","category":"page"},{"location":"examples/implicit-model/","page":"Implicit orthogonal regression","title":"Implicit orthogonal regression","text":"First, we define the observed data and the model function. ","category":"page"},{"location":"examples/implicit-model/","page":"Implicit orthogonal regression","title":"Implicit orthogonal regression","text":"# Each row represents a point (x, y) of the ellipse\nXdata = [\n    0.50 -0.12\n    1.20 -0.60\n    1.60 -1.00\n    1.86 -1.40\n    2.12 -2.54\n    2.36 -3.36\n    2.44 -4.00\n    2.36 -4.75\n    2.06 -5.25\n    1.74 -5.64\n    1.34 -5.97\n    0.90 -6.32\n    -0.28 -6.44\n    -0.78 -6.44\n    -1.36 -6.41\n    -1.90 -6.25\n    -2.50 -5.88\n    -2.88 -5.50\n    -3.18 -5.24\n    -3.44 -4.86\n]\n\n# Ydata is not used, but is required\nYdata = zeros(size(Xdata, 1), 1)\nnothing; # hide","category":"page"},{"location":"examples/implicit-model/","page":"Implicit orthogonal regression","title":"Implicit orthogonal regression","text":"function f!(X::Matrix{Float64}, beta::Vector{Float64}, Y::Matrix{Float64})\n    x0, y0, a, b, θ = beta\n    x = X[:, 1]\n    y = X[:, 2]\n    Y .=  ((x .- x0) * cos(θ) .+ (y .- y0) * sin(θ)).^2 / a^2 .+ \n          ((y .- y0) * cos(θ) .- (x .- x0) * sin(θ)).^2 / b^2 .- 1\n    return nothing\nend","category":"page"},{"location":"examples/implicit-model/","page":"Implicit orthogonal regression","title":"Implicit orthogonal regression","text":"Then, we define a plausible initial guess bmbeta_0 for the model parameters, as well as the corresponding bounds.","category":"page"},{"location":"examples/implicit-model/","page":"Implicit orthogonal regression","title":"Implicit orthogonal regression","text":"beta0 =[0.0, 0.0, 1.0, 1.0, 0.0]\n\nlower = [-1e2, -1e2, 0e0, 0e0, -π/2]\nupper = [+1e2, +1e2, 1e2, 1e2, +π/2]\nnothing; # hide","category":"page"},{"location":"examples/implicit-model/","page":"Implicit orthogonal regression","title":"Implicit orthogonal regression","text":"Here, we expect the measurement error to be the same across both bmX coordinates, so a special weighting scheme is unnecessary.","category":"page"},{"location":"examples/implicit-model/","page":"Implicit orthogonal regression","title":"Implicit orthogonal regression","text":"weight_x = 1.0\nnothing; # hide","category":"page"},{"location":"examples/implicit-model/","page":"Implicit orthogonal regression","title":"Implicit orthogonal regression","text":"We can now launch the regression! As the problem is implicit, we set task=:implicitODR. If you want to see a brief computation report, set report=:short.","category":"page"},{"location":"examples/implicit-model/","page":"Implicit orthogonal regression","title":"Implicit orthogonal regression","text":"sol = odr_fit(f!, Xdata, Ydata, beta0, bounds=(lower, upper), weight_x=weight_x,\n    task=:implicitODR, report=:none);","category":"page"},{"location":"examples/implicit-model/","page":"Implicit orthogonal regression","title":"Implicit orthogonal regression","text":"The result is packed in a OdrResult struct. Let's check the solution convergence and the estimated model parameters.","category":"page"},{"location":"examples/implicit-model/","page":"Implicit orthogonal regression","title":"Implicit orthogonal regression","text":"sol.stopreason","category":"page"},{"location":"examples/implicit-model/","page":"Implicit orthogonal regression","title":"Implicit orthogonal regression","text":"sol.beta","category":"page"},{"location":"examples/implicit-model/","page":"Implicit orthogonal regression","title":"Implicit orthogonal regression","text":"All fine! Let's plot the solution.","category":"page"},{"location":"examples/implicit-model/","page":"Implicit orthogonal regression","title":"Implicit orthogonal regression","text":"# Plot observed data\nscatter(Xdata[:, 1], Xdata[:, 2], label=\"Data\", legend=false)\n\n# Plot fitted ellipse\nx0, y0, a, b, θ = sol.beta\nt = range(0, 2π; length=200)\nellipse_x = x0 .+ a .* cos.(t) .* cos(θ) .- b .* sin.(t) .* sin(θ)\nellipse_y = y0 .+ a .* cos.(t) .* sin(θ) .+ b .* sin.(t) .* cos(θ)\nplot!(ellipse_x, ellipse_y, color=:orange, linewidth=2, label=\"Fit\")\nxlabel!(\"x\")\nylabel!(\"y\")\nsavefig(\"implicit-model-plot.svg\"); nothing # hide","category":"page"},{"location":"examples/implicit-model/","page":"Implicit orthogonal regression","title":"Implicit orthogonal regression","text":"(Image: )","category":"page"},{"location":"#Odrpack.jl","page":"Home","title":"Odrpack.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Odrpack.jl is Julia package that provides bindings for the well-known weighted orthogonal distance regression (ODR) solver odrpack95. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Orthogonal distance regression, also known as errors-in-variables regression, is designed primarily for instances when both the explanatory and response variables have significant errors. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Deming regression; special case of ODR.)","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nThis package is still in early alpha stage, and APIs can change any time in the future. Discussions and potential use cases are extremely welcome!","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Odrpack.jl can be installed using the Julia package manager. From the Julia REPL, type ] to enter the Pkg REPL mode and run:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add Odrpack","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A basic fit can be performed by passing the model function, data, and initial parameter estimates to odr_fit.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Odrpack\n\nfunction f!(x::Vector{Float64}, beta::Vector{Float64}, y::Vector{Float64})\n    y .= beta[1] .* exp.(beta[2] .* x)\n    return nothing\nend\n\nxdata = [0.982, 1.998, 4.978, 6.01]\nydata = [2.7, 7.4, 148.0, 403.0]\n\nbeta0 = [2.0, 0.5]\nbounds = ([0.0, 0.0], [10.0, 0.9])\n\nsol = odr_fit(\n    f!,\n    xdata,\n    ydata,\n    beta0,\n    bounds=bounds,\n    # rptfile=\"test_output.txt\",\n    # report=:short\n)\n\nprintln(\"Optimized β    : \" , round.(sol.beta, sigdigits=5))\nprintln(\"Optimized δ    : \", round.(sol.delta, sigdigits=5))\nprintln(\"Optimized x + δ: \", round.(sol.xplusd, sigdigits=5))","category":"page"},{"location":"examples/explicit-model/#Explicit-orthogonal-regression","page":"Explicit orthogonal regression","title":"Explicit orthogonal regression","text":"","category":"section"},{"location":"examples/explicit-model/","page":"Explicit orthogonal regression","title":"Explicit orthogonal regression","text":"Estimate the parameters of a scalar non-linear model from experimental data.","category":"page"},{"location":"examples/explicit-model/","page":"Explicit orthogonal regression","title":"Explicit orthogonal regression","text":"y = f(x bmbeta) =  fracbeta_1 x^2 + x (1-x)beta_1 x^2 + 2 x (1-x) + beta_2 (1-x)^2","category":"page"},{"location":"examples/explicit-model/","page":"Explicit orthogonal regression","title":"Explicit orthogonal regression","text":"using Odrpack\nusing Plots","category":"page"},{"location":"examples/explicit-model/","page":"Explicit orthogonal regression","title":"Explicit orthogonal regression","text":"First, we define the experimental data and the model function. ","category":"page"},{"location":"examples/explicit-model/","page":"Explicit orthogonal regression","title":"Explicit orthogonal regression","text":"xdata = [0.100, 0.300, 0.400, 0.500, 0.600, 0.700, 0.800]\nydata = [0.059, 0.243, 0.364, 0.486, 0.583, 0.721, 0.824]\nnothing; # hide","category":"page"},{"location":"examples/explicit-model/","page":"Explicit orthogonal regression","title":"Explicit orthogonal regression","text":"function f!(x::Vector{Float64}, beta::Vector{Float64}, y::Vector{Float64})\n    b1, b2 = beta\n    y .= (b1 .* x.^2 .+ x .* (1 .- x)) ./ (b1 .* x.^2 .+ 2 .* x .* (1 .- x) .+ b2 .* (1 .- x).^2)\n    return nothing\nend","category":"page"},{"location":"examples/explicit-model/","page":"Explicit orthogonal regression","title":"Explicit orthogonal regression","text":"Then, we define an initial guess for the model parameters beta and, optionally, also the corresponding bounds.","category":"page"},{"location":"examples/explicit-model/","page":"Explicit orthogonal regression","title":"Explicit orthogonal regression","text":"beta0 = [1.0, 1.0]\nbounds = ([0.0, 0.0], [2.0, 2.0])\nnothing; # hide","category":"page"},{"location":"examples/explicit-model/","page":"Explicit orthogonal regression","title":"Explicit orthogonal regression","text":"Lastly, we define the weights for x and y based on a suitable rationale, such as the estimated uncertainty of each variable.","category":"page"},{"location":"examples/explicit-model/","page":"Explicit orthogonal regression","title":"Explicit orthogonal regression","text":"sigma_x = 0.01\nsigma_y = 0.05\n\nweight_x = 1/sigma_x^2\nweight_y = 1/sigma_y^2\nnothing; # hide","category":"page"},{"location":"examples/explicit-model/","page":"Explicit orthogonal regression","title":"Explicit orthogonal regression","text":"We can now launch the regression! If you want to see a brief computation report, set report=:short.","category":"page"},{"location":"examples/explicit-model/","page":"Explicit orthogonal regression","title":"Explicit orthogonal regression","text":"sol = odr_fit(f!, xdata, ydata, beta0; bounds=bounds, weight_x=weight_x, weight_y=weight_y)","category":"page"},{"location":"examples/explicit-model/","page":"Explicit orthogonal regression","title":"Explicit orthogonal regression","text":"The result is packed in a OdrResult struct. Let's check the solution convergence and the estimated model parameters.","category":"page"},{"location":"examples/explicit-model/","page":"Explicit orthogonal regression","title":"Explicit orthogonal regression","text":"sol.stopreason","category":"page"},{"location":"examples/explicit-model/","page":"Explicit orthogonal regression","title":"Explicit orthogonal regression","text":"sol.beta","category":"page"},{"location":"examples/explicit-model/","page":"Explicit orthogonal regression","title":"Explicit orthogonal regression","text":"All fine! Let's plot the solution.","category":"page"},{"location":"examples/explicit-model/","page":"Explicit orthogonal regression","title":"Explicit orthogonal regression","text":"# Plot experimental data\nscatter(xdata, ydata, label=\"Data\", legend=:topleft)\n\n# Plot fitted model\nxm = collect(range(0.0, 1.0; length=100))\nym = zeros(length(xm))\nf!(xm, sol.beta, ym)\nplot!(xm, ym, label=\"Fitted model\")\nxlabel!(\"x\")\nylabel!(\"y\")\nsavefig(\"explicit-model-plot.svg\"); nothing # hide","category":"page"},{"location":"examples/explicit-model/","page":"Explicit orthogonal regression","title":"Explicit orthogonal regression","text":"(Image: )","category":"page"}]
}
